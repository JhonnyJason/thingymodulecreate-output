// Generated by CoffeeScript 2.5.1
(function() {
  var Gitlab, addDeployKey, addWebhook, c, checkAccess, createRepository, deleteRepository, getCurrentUserId, getDeletableProjectID, getDeployKeyId, getGitlab, getRepoIdString, getWebhookId, gitlabservice, globalScope, log, olog, ostr, printError, printSuccess, removeDeployKey, removeWebhook, retrieveAllDeployKeys, retrieveAllRepositories, retrieveAllWebhooks, urlHandler;

  gitlabservice = {
    name: "gitlabservice"
  };

  //###########################################################
  //region logPrintFunctions
  log = function(arg) {
    if (allModules.debugmodule.modulesToDebug["cloudservicemodule"] != null) {
      console.log("[gitlabservice]: " + arg);
    }
  };

  ostr = function(o) {
    return JSON.stringify(o, null, 4);
  };

  olog = function(o) {
    return log("\n" + ostr(o));
  };

  printError = function(msg) {
    return console.log(c.red("\n" + msg));
  };

  printSuccess = function(msg) {
    return console.log(c.green("\n" + msg));
  };

  //endregion

  //###########################################################
  //region modulesFromEnvironment
  Gitlab = require('gitlab').Gitlab;

  c = require('chalk');

  //###########################################################
  urlHandler = null;

  globalScope = null;

  //endregion

  //###########################################################
  gitlabservice.initialize = function() {
    log("gitlabservice.initialize");
    urlHandler = allModules.urlhandlermodule;
    globalScope = allModules.globalscopemodule;
  };

  //###########################################################
  //region internalFunctions
  getGitlab = function(host, token) {
    var options;
    log("getGitlab");
    options = {
      host: host,
      token: token
    };
    return new Gitlab(options);
  };

  checkAccess = async function(service) {
    var err, gitlab, userId;
    log("checkAccess");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    try {
      userId = (await getCurrentUserId(service));
      if (!service.userId) {
        service.userId = userId;
      } else if (service.userId !== userId) {
        throw new Error("No userId match!");
      }
      return true;
    } catch (error) {
      err = error;
      return false;
    }
  };

  getRepoIdString = function(service, repo) {
    return service.username + "/" + repo;
  };

  // return service.username + "%2F" + repo

  //###########################################################
  //region retrieveAllFunctions
  retrieveAllRepositories = async function(service) {
    var data, gitlab, options;
    log("retrieveAllRepositories");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    options = {
      owned: true,
      simple: true,
      perPage: 100,
      maxPages: 100
    };
    data = (await gitlab.Users.projects(service.userId, options));
    return data.map(function(project) {
      return project.name;
    });
  };

  retrieveAllDeployKeys = async function(service, repo) {
    var gitlab, options, stringId;
    gitlab = getGitlab(service.hostURL, service.accessToken);
    stringId = getRepoIdString(service, repo);
    options = {
      projectId: stringId,
      perPage: 100,
      maxPages: 100
    };
    return (await gitlab.DeployKeys.all(options));
  };

  retrieveAllWebhooks = async function(service, repo) {
    var gitlab, options, stringId;
    gitlab = getGitlab(service.hostURL, service.accessToken);
    stringId = getRepoIdString(service, repo);
    options = {
      perPage: 100,
      maxPages: 100
    };
    return (await gitlab.ProjectHooks.all(stringId, options));
  };

  //endregion

  //###########################################################
  //region retrieveSingleIds
  getDeletableProjectID = function(projects, service, repo) {
    var debugMessage, i, len, pathWithNamespace, project;
    pathWithNamespace = service.username + "/" + repo;
    for (i = 0, len = projects.length; i < len; i++) {
      project = projects[i];
      if (project.path_with_namespace.toLowerCase() === pathWithNamespace.toLowerCase()) {
        return project.id;
      }
    }
    debugMessage = "\n@" + pathWithNamespace + "\n" + ostr(projects);
    throw "getDeletableProjectID: did not find deletable project!" + debugMessage;
  };

  getDeployKeyId = async function(service, repo, title) {
    var allKeys, i, key, len;
    log("getDeployKeyId");
    allKeys = (await retrieveAllDeployKeys(service, repo));
    olog(allKeys);
    for (i = 0, len = allKeys.length; i < len; i++) {
      key = allKeys[i];
      if (title === key.title) {
        return key.id;
      }
    }
    throw new Error("No deployKey found! title: " + title);
  };

  getWebhookId = async function(service, repo, url) {
    var allHooks, hook, i, len;
    allHooks = (await retrieveAllWebhooks(service, repo));
// olog allHooks
    for (i = 0, len = allHooks.length; i < len; i++) {
      hook = allHooks[i];
      if (url === hook.url) {
        return hook.id;
      }
    }
    throw new Error("No Webhook found! url: " + url);
  };

  getCurrentUserId = async function(service) {
    var gitlab, user;
    gitlab = getGitlab(service.hostURL, service.accessToken);
    user = (await gitlab.Users.current());
    return user.id;
  };

  //endregion

  //###########################################################
  //region repoManipulations
  createRepository = async function(service, repo, visible) {
    var gitlab, options, visibility;
    log("createRepository");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    if (visible) {
      visibility = "public";
    } else {
      visibility = "private";
    }
    options = {
      name: repo,
      visibility: visibility
    };
    await gitlab.Projects.create(options);
  };

  deleteRepository = async function(service, repo) {
    var gitlab, id, options, projects, result;
    log("deleteRepository");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    options = {
      search: repo,
      owned: true,
      simple: true
    };
    projects = (await gitlab.Projects.all(options));
    if (projects.length === 0) {
      return;
    }
    // olog projects
    id = getDeletableProjectID(projects, service, repo);
    // log id
    result = (await gitlab.Projects.remove(id));
  };

  //###########################################################
  // olog result
  addDeployKey = async function(service, repo, key, title) {
    var gitlab, options, stringId;
    log("addDeployKey");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    stringId = getRepoIdString(service, repo);
    options = {
      title: title,
      key: key
    };
    await gitlab.DeployKeys.add(stringId, options);
  };

  removeDeployKey = async function(service, repo, title) {
    var gitlab, keyId, stringId;
    log("removeDeployKey");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    stringId = getRepoIdString(service, repo);
    keyId = (await getDeployKeyId(service, repo, title));
    log("on repo with stringId: " + stringId);
    log("trying to remove deploy key with keyId: " + keyId);
    await gitlab.DeployKeys.remove(stringId, keyId);
  };

  //###########################################################
  addWebhook = async function(service, repo, url, secret) {
    var gitlab, options, stringId;
    log("addWebhook");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    stringId = getRepoIdString(service, repo);
    options = {
      push_events: true,
      token: secret
    };
    await gitlab.ProjectHooks.add(stringId, url, options);
  };

  removeWebhook = async function(service, repo, url) {
    var gitlab, hookId, stringId;
    log("removeWebhook");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    stringId = getRepoIdString(service, repo);
    hookId = (await getWebhookId(service, repo, url));
    await gitlab.ProjectHooks.remove(stringId, hookId);
  };

  //endregion

  //endregion

  //###########################################################
  //region exposedFunctions
  gitlabservice.check = async function(service) {
    var scope;
    log("gitlabservice.check");
    service.isAccessible = (await checkAccess(service));
    if (service.isAccessible) {
      scope = (await retrieveAllRepositories(service));
      globalScope.addServiceScope(scope, service);
    }
  };

  //###########################################################
  //region repoManipulations
  gitlabservice.deleteRepository = async function(service, repo) {
    await deleteRepository(service, repo);
  };

  gitlabservice.createRepository = async function(service, repo, visible) {
    await createRepository(service, repo, visible);
  };

  //###########################################################
  gitlabservice.addDeployKey = async function(service, repoName, pubKey, title) {
    await addDeployKey(service, repoName, pubKey, title);
  };

  gitlabservice.removeDeployKey = async function(service, repoName, title) {
    await removeDeployKey(service, repoName, title);
  };

  //###########################################################
  gitlabservice.addWebhook = async function(service, repoName, url, secret) {
    await addWebhook(service, repoName, url, secret);
  };

  gitlabservice.removeWebhook = async function(service, repoName, url) {
    await removeWebhook(service, repoName, url);
  };

  //endregion

  //###########################################################
  gitlabservice.getSSHURLBase = function(service) {
    var serverName;
    log("gitlabservice.getSSHURLBase");
    serverName = urlHandler.getServerName(service.hostURL);
    return "git@" + serverName + ":" + service.username;
  };

  gitlabservice.getHTTPSURLBase = function(service) {
    log("gitlabservice.getHTTPSURLBase");
    return service.hostURL + "/" + service.username;
  };

  //endregion
  module.exports = gitlabservice;

}).call(this);
