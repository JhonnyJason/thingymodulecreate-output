// Generated by CoffeeScript 2.5.1
(function() {
  var Gitlab, c, checkAccess, createRepository, deleteRepository, getDeletableProjectID, getGitlab, gitlabservice, globalScope, log, olog, ostr, printError, printSuccess, retrieveAllRepositories, urlHandler;

  gitlabservice = {
    name: "gitlabservice"
  };

  //region modulesFromEnvironment
  //region node_modules
  Gitlab = require('gitlab').Gitlab;

  c = require('chalk');

  //endregion

  //region localModules
  urlHandler = null;

  globalScope = null;

  //endregion
  //endregion

  //region logPrintFunctions
  //#############################################################################
  log = function(arg) {
    if (allModules.debugmodule.modulesToDebug["cloudservicemodule"] != null) {
      console.log("[gitlabservice]: " + arg);
    }
  };

  ostr = function(o) {
    return JSON.stringify(o, null, 4);
  };

  olog = function(o) {
    return log("\n" + ostr(o));
  };

  printError = function(msg) {
    return console.log(c.red("\n" + msg));
  };

  printSuccess = function(msg) {
    return console.log(c.green("\n" + msg));
  };

  //endregion
  //#############################################################################
  gitlabservice.initialize = function() {
    log("gitlabservice.initialize");
    urlHandler = allModules.urlhandlermodule;
    globalScope = allModules.globalscopemodule;
  };

  //region internalFunctions
  getGitlab = function(host, token) {
    var options;
    log("getGitlab");
    options = {
      host: host,
      token: token
    };
    return new Gitlab(options);
  };

  checkAccess = async function(service) {
    var err, gitlab, options;
    log("checkAccess");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    try {
      options = {
        username: service.username,
        maxPages: 1
      };
      await gitlab.Users.all(options);
      return true;
    } catch (error) {
      err = error;
      return false;
    }
  };

  retrieveAllRepositories = async function(service) {
    var data, gitlab, options;
    log("retrieveAllRepositories");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    options = {
      owned: true,
      simple: true,
      perPage: 100,
      maxPages: 1000
    };
    data = (await gitlab.Projects.all(options));
    return data.map(function(project) {
      return project.name;
    });
  };

  createRepository = async function(service, repo, visible) {
    var gitlab, options, visibility;
    log("createRepository");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    if (visible) {
      visibility = "public";
    } else {
      visibility = "private";
    }
    options = {
      name: repo,
      visibility: visibility
    };
    await gitlab.Projects.create(options);
  };

  getDeletableProjectID = function(projects, service, repo) {
    var debugMessage, i, len, pathWithNamespace, project;
    log("selectDeletableProject");
    pathWithNamespace = service.username + "/" + repo;
    for (i = 0, len = projects.length; i < len; i++) {
      project = projects[i];
      if (project.path_with_namespace.toLowerCase() === pathWithNamespace.toLowerCase()) {
        return project.id;
      }
    }
    debugMessage = "\n@" + pathWithNamespace + "\n" + ostr(projects);
    throw "getDeletableProjectID: did not find deletable project!" + debugMessage;
  };

  deleteRepository = async function(service, repo) {
    var gitlab, id, options, projects, result;
    log("deleteRepository");
    gitlab = getGitlab(service.hostURL, service.accessToken);
    options = {
      search: repo,
      owned: true,
      simple: true
    };
    projects = (await gitlab.Projects.all(options));
    if (projects.length === 0) {
      return;
    }
    // olog projects
    id = getDeletableProjectID(projects, service, repo);
    // log id
    result = (await gitlab.Projects.remove(id));
  };

  //endregion

  //region exposedFunctions
  // olog result
  gitlabservice.check = async function(service) {
    var scope;
    log("gitlabservice.check");
    service.isAccessible = (await checkAccess(service));
    if (service.isAccessible) {
      scope = (await retrieveAllRepositories(service));
      globalScope.addServiceScope(scope, service);
    }
  };

  gitlabservice.deleteRepository = async function(service, repo) {
    await deleteRepository(service, repo);
  };

  gitlabservice.createRepository = async function(service, repo, visible) {
    await createRepository(service, repo, visible);
  };

  gitlabservice.getSSHURLBase = function(service) {
    var serverName;
    log("gitlabservice.getSSHURLBase");
    serverName = urlHandler.getServerName(service.hostURL);
    return "git@" + serverName + ":" + service.username;
  };

  gitlabservice.getHTTPSURLBase = function(service) {
    log("gitlabservice.getHTTPSURLBase");
    return service.hostURL + "/" + service.username;
  };

  //endregion
  module.exports = gitlabservice;

}).call(this);
