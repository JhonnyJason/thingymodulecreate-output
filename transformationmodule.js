// Generated by CoffeeScript 2.5.1
(function() {
  var CLI, Spinner, addSubmodule, cloud, commitChanges, createNewRemote, deinitSubmodule, deleteModulesReferences, fs, git, gitmodulesHandler, initPush, log, moduleToTempDir, pathHandler, print, reintroduceDirectory, remoteHandler, removeFromGit, removeFromStaged, removeLinesFromGitmodules, transformToDirectory, transformToSubmodule, transformationmodule, user;

  transformationmodule = {
    name: "transformationmodule"
  };

  //region modulesFromEnvironment
  //region node_modules
  CLI = require('clui');

  Spinner = CLI.Spinner;

  fs = require("fs-extra");

  gitmodulesHandler = require("gitmodules-file-handler");

  //endregion

  //retion localModules
  git = null;

  user = null;

  cloud = null;

  pathHandler = null;

  remoteHandler = null;

  //endregion
  //endregion

  //region logPrintFunctions
  //#############################################################################
  log = function(arg) {
    if (allModules.debugmodule.modulesToDebug["transformationmodule"] != null) {
      console.log("[transformationmodule]: " + arg);
    }
  };

  print = function(arg) {
    return console.log(arg);
  };

  //endregion
  //#############################################################################
  transformationmodule.initialize = function() {
    log("transformationmodule.initialize");
    git = allModules.gitmodule;
    user = allModules.userinquirermodule;
    cloud = allModules.cloudservicemodule;
    pathHandler = allModules.pathhandlermodule;
    remoteHandler = allModules.remotehandlermodule;
  };

  
  //region internalFunctions
  //region helperFunctions
  moduleToTempDir = async function(tmp, module) {
    var gitDir;
    log("moduleToTempDir");
    await fs.move(module, tmp);
    gitDir = pathHandler.resolve(tmp, ".git");
    await fs.remove(gitDir);
  };

  reintroduceDirectory = async function(tmp, module) {
    log("reintroduceAsDirectory");
    await fs.remove(module);
    await fs.move(tmp, module);
  };

  removeFromGit = async function(modulePath) {
    var base, err;
    log("removeFromGit");
    base = pathHandler.thingyModuleBase;
    try {
      await git.rmCached(base, modulePath);
    } catch (error) {
      err = error;
      log(err);
      log((await git.stash(base)));
      try {
        log((await git.rmCached(base, modulePath)));
      } catch (error) {
        err = error;
        log("Error after stashing wtf has happened!?!?");
        log(err);
      }
      log((await git.stashPop(base)));
    }
  };

  removeFromStaged = async function(modulePath) {
    var base, err, gitmodulesPath;
    log("removeFromStaged");
    base = pathHandler.thingyModuleBase;
    gitmodulesPath = pathHandler.resolve(pathHandler.parentPath, ".gitmodules");
    try {
      await git.restoreStaged(base, gitmodulesPath);
    } catch (error) {
      err = error;
      log(err);
    }
    try {
      await git.restoreStaged(base, modulePath);
    } catch (error) {
      err = error;
      log(err);
    }
  };

  deinitSubmodule = async function(base, module) {
    var err;
    log("deinitSubmodule");
    try {
      await git.deinitSubmodule(base, module);
    } catch (error) {
      err = error;
      log(err);
    }
  };

  removeLinesFromGitmodules = async function(modulePath) {
    var gitmodulesFile, gitmodulesObject, relativeDir, submodule;
    log("removeLinesFromGitmodules");
    gitmodulesFile = pathHandler.resolve(pathHandler.parentPath, ".gitmodules");
    gitmodulesObject = (await gitmodulesHandler.readNewGitmodulesFile(gitmodulesFile));
    relativeDir = pathHandler.relative(pathHandler.parentPath, modulePath);
    submodule = gitmodulesObject.getModule(relativeDir);
    if (submodule) {
      submodule.remove();
    }
    await gitmodulesObject.writeToFile();
  };

  deleteModulesReferences = async function(modulePath) {
    var gitDir, refDir, relativeDir;
    log("deleteModulesReferences");
    gitDir = pathHandler.resolve(pathHandler.parentPath, ".git");
    relativeDir = pathHandler.relative(pathHandler.parentPath, modulePath);
    refDir = pathHandler.resolve(gitDir, "modules", relativeDir);
    return (await fs.remove(refDir));
  };

  initPush = async function(path, remote) {
    var err, status, statusMessage;
    statusMessage = "initialize and push " + remote.getRepo() + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await git.initPush(path, remote);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
  };

  createNewRemote = async function(repoName) {
    var err, message, status, statusMessage, visible;
    message = "Make module " + repoName + " public?";
    visible = (await user.inquireYesNoDecision(message, true));
    statusMessage = "Creating remote " + repoName + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await cloud.createRepository(repoName, visible);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
    return remoteHandler.getRemoteObject(repoName);
  };

  commitChanges = async function(base, module) {
    var err, status, statusMessage;
    log("commitChanges");
    statusMessage = "commit changes of " + module + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await git.add(base, module);
      await git.commit(base, statusMessage);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
  };

  addSubmodule = async function(path, remote, label) {
    var err, status, statusMessage;
    statusMessage = "add submodule to " + label + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await git.addSubmodule(path, remote, label);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
  };

  //endregion
  transformToDirectory = async function(name, thingy) {
    var base, modulePath, tmpPath;
    log("transformToDirectory");
    base = pathHandler.thingyModuleBase;
    modulePath = pathHandler.resolve(pathHandler.thingyModuleBase, name);
    tmpPath = pathHandler.resolve(pathHandler.temporaryFilesPath, name);
    await moduleToTempDir(tmpPath, modulePath);
    await deinitSubmodule(base, modulePath);
    await deleteModulesReferences(modulePath);
    await removeLinesFromGitmodules(modulePath);
    await removeFromStaged(modulePath);
    await removeFromGit(modulePath);
    await reintroduceDirectory(tmpPath, modulePath);
  };

  transformToSubmodule = async function(name, thingy) {
    var destinationPath, exists, modulePath, remote, repoName, tmpPath;
    log("transformToSubmodule");
    repoName = thingy.name + "-" + name;
    remote = (await createNewRemote(repoName));
    modulePath = pathHandler.resolve(pathHandler.thingyModuleBase, name);
    exists = (await pathHandler.directoryExists(modulePath));
    if (!exists) {
      throw "Module to transform does not exist!";
    }
    tmpPath = pathHandler.temporaryFilesPath;
    destinationPath = pathHandler.resolve(tmpPath, name);
    await fs.move(modulePath, destinationPath);
    await commitChanges(pathHandler.thingyModuleBase, modulePath);
    await initPush(destinationPath, remote);
    await fs.remove(destinationPath);
    await addSubmodule(pathHandler.thingyModuleBase, remote, name);
  };

  //endregion

  //region exposedFunctions
  transformationmodule.step = async function(step, thingy) {
    log("transformationsmodule.step");
    log(step);
    if (step[0] === "directory") {
      await transformToDirectory(step[1], thingy);
    }
    if (step[0] === "submodule") {
      await transformToSubmodule(step[1], thingy);
    }
  };

  //endregion
  module.exports = transformationmodule;

}).call(this);
