// Generated by CoffeeScript 2.5.1
(function() {
  var CLI, Spinner, addSubmodule, clone, cloud, constructionmodule, createNewRemote, createTemporaryModulePath, directoryStep, fs, git, initPush, log, merge, mergeStep, moduleCreateStep, moduleMergeStep, moduleStepProxy, moduleUseStep, move, olog, ostr, pathHandler, print, recipe, remoteHandler, stepProxy, submoduleStep, thingyModule, user;

  constructionmodule = {
    name: "constructionmodule"
  };

  //region modulesFromEnvironment
  //region node_modules
  CLI = require('clui');

  Spinner = CLI.Spinner;

  fs = require("fs-extra");

  //endregion

  //region localModules
  git = null;

  user = null;

  cloud = null;

  recipe = null;

  pathHandler = null;

  thingyModule = null;

  remoteHandler = null;

  //endregion
  //endregion

  //region logPrintFunctions
  //#############################################################################
  log = function(arg) {
    if (allModules.debugmodule.modulesToDebug["constructionmodule"] != null) {
      console.log("[constructionmodule]: " + arg);
    }
  };

  olog = function(o) {
    return log("\n" + ostr(o));
  };

  ostr = function(o) {
    return JSON.stringify(o, null, 4);
  };

  print = function(arg) {
    return console.log(arg);
  };

  //endregion
  //#############################################################################
  constructionmodule.initialize = function() {
    log("constructionmodule.initialize");
    git = allModules.gitmodule;
    user = allModules.userinquirermodule;
    cloud = allModules.cloudservicemodule;
    recipe = allModules.recipemodule;
    thingyModule = allModules.thingymodule;
    pathHandler = allModules.pathhandlermodule;
    remoteHandler = allModules.remotehandlermodule;
  };

  
  //region internalProperties
  stepProxy = {};

  stepProxy.merge = function(step, thingy, d) {
    return mergeStep(step, thingy, d);
  };

  stepProxy.directory = function(step, thingy, d) {
    return directoryStep(step, thingy, d);
  };

  stepProxy.submodule = function(step, thingy, d) {
    return submoduleStep(step, thingy, d);
  };

  moduleStepProxy = {};

  moduleStepProxy.merge = function(step, thingy, d) {
    return moduleMergeStep(step, thingy, d);
  };

  moduleStepProxy.create = function(step, thingy, d) {
    return moduleCreateStep(step, thingy, d);
  };

  moduleStepProxy.use = function(step, thingy, d) {
    return moduleUseStep(step, thingy, d);
  };

  //endregion

  //region internalFunctions
  //region proxyStepFunctions
  submoduleStep = async function(step, thingy, d) {
    log("submoduleStep");
    await moduleStepProxy[step[2]](step, thingy, d);
  };

  directoryStep = async function(step, thingy, d) {
    log("mergeStep");
    await moduleStepProxy[step[2]](step, thingy, d);
  };

  //endregion

  //region helperFunctions
  move = async function(src, dest, file) {
    var destinationPath, sourcePath;
    sourcePath = pathHandler.resolve(src, file);
    destinationPath = pathHandler.resolve(dest, file);
    return (await fs.move(sourcePath, destinationPath, {
      overwrite: true
    }));
  };

  merge = async function(repo, dest) {
    var base, err, files, gitDir, promises, remote, repoName, repoPath, status, statusMessage;
    remote = remoteHandler.createRemoteFromUserInput(repo);
    repoName = remote.getRepo();
    base = pathHandler.temporaryFilesPath;
    statusMessage = "Merging " + remote.getRepo() + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await git.clone(remote, base);
      repoPath = pathHandler.resolve(base, repoName);
      gitDir = pathHandler.resolve(repoPath, ".git");
      await fs.remove(gitDir);
      files = (await fs.readdir(repoPath));
      promises = files.map(function(el) {
        return move(repoPath, dest, el);
      });
      await Promise.all(promises);
      await fs.remove(repoPath);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
  };

  createTemporaryModulePath = async function(moduleName) {
    var modulePath, tmp;
    tmp = pathHandler.temporaryFilesPath;
    modulePath = pathHandler.resolve(tmp, moduleName);
    await fs.mkdirp(modulePath);
    return modulePath;
  };

  createNewRemote = async function(repoName) {
    var err, message, status, statusMessage, visible;
    message = "Make module " + repoName + " public?";
    visible = (await user.inquireYesNoDecision(message, true));
    statusMessage = "Creating remote " + repoName + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await cloud.createRepository(repoName, visible);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
    return remoteHandler.getRemoteObject(repoName);
  };

  initPush = async function(path, remote) {
    var err, status, statusMessage;
    statusMessage = "initialize and push " + remote.getRepo() + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await git.initPush(path, remote);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
  };

  addSubmodule = async function(path, remote, label) {
    var err, status, statusMessage;
    statusMessage = "add submodule to " + label + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await git.addSubmodule(path, remote, label);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
  };

  clone = async function(remote, base) {
    var err, status, statusMessage;
    statusMessage = "cloning " + remote.getRepo() + "...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await git.clone(remote, base);
    } catch (error) {
      err = error;
      log(err);
    } finally {
      status.stop();
    }
  };

  //endregion
  mergeStep = async function(step, thingy, direct) {
    var thingyPath;
    log("mergeStep");
    //# step[0] is "merge"
    //# step[1] is something identifying the repository
    if (direct) {
      thingyPath = thingy.basePath;
    } else {
      thingyPath = pathHandler.resolve(thingy.basePath, thingy.name);
    }
    await merge(step[1], thingyPath);
  };

  moduleMergeStep = async function(step, thingy, direct) {
    var destPath, modulePath, remote, repoName, thingyPath;
    log("moduleMergeStep");
    // step[0] is "directory" or "submodule" 
    // step[1] is label of directory
    // step[2] is "merge"
    // step[3] something identifying the repository
    if (direct) {
      thingyPath = thingy.basePath;
    } else {
      thingyPath = pathHandler.resolve(thingy.basePath, thingy.name);
    }
    if (step[0] === "directory") {
      destPath = pathHandler.resolve(thingyPath, step[1]);
      await fs.mkdir(destPath);
      await merge(step[3], destPath);
    } else {
      repoName = thingy.name + "-" + step[1];
      modulePath = (await createTemporaryModulePath(repoName));
      await merge(step[3], modulePath);
      remote = (await createNewRemote(repoName));
      await initPush(modulePath, remote);
      await fs.remove(modulePath);
      await addSubmodule(thingyPath, remote, step[1]);
    }
  };

  moduleCreateStep = async function(step, thingy, direct) {
    var constructionPlan, destPath, rcp, remote, repoName, thingyPath, tmp, tmpThingyModulePath;
    log("moduleCreateStep");
    // step[0] is "directory" or "submodule" 
    // step[1] is label of directory
    // step[2] is "create"
    // step[3] is thingyModuleType
    if (direct) {
      thingyPath = thingy.basePath;
    } else {
      thingyPath = pathHandler.resolve(thingy.basePath, thingy.name);
    }
    if (step[0] === "directory") {
      destPath = pathHandler.resolve(thingyPath, step[1]);
      await fs.mkdir(destPath);
      repoName = thingy.name + "-" + step[1];
      rcp = (await recipe.getModuleRecipe(step[3]));
      print(">> Constructing thingy(versionless) " + repoName + ":");
      constructionPlan = (await recipe.toConstructionPlan(rcp));
      await thingyModule.createVersionless(repoName, step[3], constructionPlan, destPath);
    } else {
      repoName = thingy.name + "-" + step[1];
      rcp = (await recipe.getModuleRecipe(step[3]));
      print(">> Constructing thingy " + repoName + ":");
      constructionPlan = (await recipe.toConstructionPlan(rcp));
      tmp = pathHandler.temporaryFilesPath;
      tmpThingyModulePath = pathHandler.resolve(tmp, repoName);
      await thingyModule.create(repoName, step[3], constructionPlan, tmp, rcp.individualize);
      await fs.remove(tmpThingyModulePath);
      remote = remoteHandler.getRemoteObject(repoName);
      await addSubmodule(thingyPath, remote, step[1]);
    }
  };

  moduleUseStep = async function(step, thingy, direct) {
    var base, linkPath, realPath, remote, thingyPath;
    log("moduleUseStep");
    // step[0] is "directory" or "submodule" 
    // step[1] is label of directory
    // step[2] is "use"
    // step[3] something identifying the repository
    if (direct) {
      thingyPath = thingy.basePath;
    } else {
      thingyPath = pathHandler.resolve(thingy.basePath, thingy.name);
    }
    remote = remoteHandler.createRemoteFromUserInput(step[3]);
    if (step[0] === "directory") {
      linkPath = pathHandler.resolve(thingyPath, step[1]);
      base = pathHandler.basePath;
      await clone(remote, base);
      realPath = pathHandler.resolve(base, remote.getRepo());
      await fs.ensureSymlink(realPath, linkPath);
    } else {
      await addSubmodule(thingyPath, remote, step[1]);
    }
  };

  //endregion

  //region exposedFunctions
  constructionmodule.instructionLineToConstructionStep = function(instructionLine) {
    var i, instructions, len, token;
    log("constructionmodule.instructionLineToConstructionStep");
    instructions = instructionLine.split(",");
    for (i = 0, len = instructions.length; i < len; i++) {
      token = instructions[i];
      if (typeof token !== "string") {
        throw "corrupted instructionLine: " + instructionLine;
      }
    }
    return instructions;
  };

  constructionmodule.constructStep = async function(step, thingy) {
    log("constructionmodule.constructStep");
    olog(thingy);
    olog(step);
    log(pathHandler.basePath);
    if (step[0]) {
      await stepProxy[step[0]](step, thingy, true);
    }
  };

  constructionmodule.constructVersionless = async function(thingy) {
    var i, len, plan, step;
    log("constructionmodule.constructVersionless");
    plan = thingy.constructionPlan;
    for (i = 0, len = plan.length; i < len; i++) {
      step = plan[i];
      if (step[0]) {
        await stepProxy[step[0]](step, thingy, true);
      }
    }
  };

  constructionmodule.construct = async function(thingy) {
    var i, len, plan, step;
    log("constructionmodule.construct");
    plan = thingy.constructionPlan;
    for (i = 0, len = plan.length; i < len; i++) {
      step = plan[i];
      if (step[0]) {
        await stepProxy[step[0]](step, thingy);
      }
    }
  };

  //endregion
  module.exports = constructionmodule;

}).call(this);
